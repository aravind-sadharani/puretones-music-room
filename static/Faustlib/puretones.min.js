"use strict";class FaustWasm2ScriptProcessor{constructor(t,e){this.name=t,this._log=[],this.debug="object"==typeof e&&e.debug}heap2Str(t){let e="",s=0;for(;0!==t[s];)e+=String.fromCharCode(t[s++]);return e}getNode(t,e,s){var n=new Uint8Array(t.exports.memory.buffer);let a;this.json=this.heap2Str(n),this.json_object=JSON.parse(this.json);const r=parseInt(this.json_object.inputs),i=parseInt(this.json_object.outputs);try{a=e.createScriptProcessor(s,r,i)}catch(t){return this.error("Error in createScriptProcessor: "+t),null}return a.output_handler=null,a.ins=null,a.outs=null,a.compute_handler=null,a.dspInChannnels=[],a.dspOutChannnels=[],a.fPitchwheelLabel=[],a.fCtrlLabel=new Array(128).fill(null).map((()=>[])),a.remap=(t,e,s,n,a)=>(t-e)/(s-e)*(a-n)+n,a.numIn=r,a.numOut=i,this.log(a.numIn),this.log(a.numOut),a.ptr_size=4,a.sample_size=4,a.factory=t.exports,a.HEAP=t.exports.memory.buffer,a.HEAP32=new Int32Array(a.HEAP),a.HEAPF32=new Float32Array(a.HEAP),this.log(a.HEAP),this.log(a.HEAP32),this.log(a.HEAPF32),a.outputs_timer=5,a.outputs_items=[],a.inputs_items=[],a.audio_heap_ptr=parseInt(this.json_object.size),a.audio_heap_ptr_inputs=a.audio_heap_ptr,a.audio_heap_ptr_outputs=a.audio_heap_ptr_inputs+a.numIn*a.ptr_size,a.audio_heap_inputs=a.audio_heap_ptr_outputs+a.numOut*a.ptr_size,a.audio_heap_outputs=a.audio_heap_inputs+a.numIn*s*a.sample_size,a.dsp=0,a.pathTable=[],a.update_outputs=()=>{a.outputs_items.length>0&&a.output_handler&&0==a.outputs_timer--&&(a.outputs_timer=5,a.outputs_items.forEach((t=>a.output_handler(t,a.factory.getParamValue(a.dsp,a.pathTable[t])))))},a.compute=t=>{for(let e=0;e<a.numIn;e++){const s=t.inputBuffer.getChannelData(e);a.dspInChannnels[e].set(s)}a.compute_handler&&a.compute_handler(s);try{a.factory.compute(a.dsp,s,a.ins,a.outs)}catch(t){console.log("ERROR in compute ("+t+")")}a.update_outputs();for(let e=0;e<a.numOut;e++){const s=t.outputBuffer.getChannelData(e),n=a.dspOutChannnels[e];s.set(n)}},a.parse_ui=t=>t.forEach((t=>a.parse_group(t))),a.parse_group=t=>t.items?a.parse_items(t.items):null,a.parse_items=t=>t.forEach((t=>a.parse_item(t))),a.parse_item=t=>{if("vgroup"===t.type||"hgroup"===t.type||"tgroup"===t.type)a.parse_items(t.items);else if("hbargraph"===t.type||"vbargraph"===t.type)a.outputs_items.push(t.address),a.pathTable[t.address]=parseInt(t.index);else if("vslider"===t.type||"hslider"===t.type||"button"===t.type||"checkbox"===t.type||"nentry"===t.type){if(a.inputs_items.push(t.address),a.pathTable[t.address]=parseInt(t.index),!t.meta)return;t.meta.forEach((e=>{const s=e.midi;if(!s)return;const n=s.trim();if("pitchwheel"===n)a.fPitchwheelLabel.push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)});else{const e=n.match(/^ctrl\s(\d+)/);if(!e)return;a.fCtrlLabel[parseInt(e[1])].push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)})}}))}},a.initAux=()=>{if(this.log("buffer_size "+s),a.onaudioprocess=a.compute,a.numIn>0){a.ins=a.audio_heap_ptr_inputs;for(let t=0;t<a.numIn;t++)a.HEAP32[(a.ins>>2)+t]=a.audio_heap_inputs+s*a.sample_size*t;const t=a.HEAP32.subarray(a.ins>>2,a.ins+a.numIn*a.ptr_size>>2);for(let e=0;e<a.numIn;e++)a.dspInChannnels[e]=a.HEAPF32.subarray(t[e]>>2,t[e]+s*a.sample_size>>2)}if(a.numOut>0){a.outs=a.audio_heap_ptr_outputs;for(let t=0;t<a.numOut;t++)a.HEAP32[(a.outs>>2)+t]=a.audio_heap_outputs+s*a.sample_size*t;const t=a.HEAP32.subarray(a.outs>>2,a.outs+a.numOut*a.ptr_size>>2);for(let e=0;e<a.numOut;e++)a.dspOutChannnels[e]=a.HEAPF32.subarray(t[e]>>2,t[e]+s*a.sample_size>>2)}a.parse_ui(this.json_object.ui),a.factory.init(a.dsp,e.sampleRate)},a.destroy=()=>{},a.getSampleRate=()=>e.sampleRate,a.getNumInputs=()=>a.numIn,a.getNumOutputs=()=>a.numOut,a.init=t=>a.factory.init(a.dsp,t),a.instanceInit=t=>a.factory.instanceInit(a.dsp,t),a.instanceConstants=t=>a.factory.instanceConstants(a.dsp,t),a.instanceResetUserInterface=()=>a.factory.instanceResetUserInterface(a.dsp),a.instanceClear=()=>a.factory.instanceClear(a.dsp),a.metadata=t=>{this.json_object.meta&&this.json_object.meta.forEach((e=>t.declare(Object.keys(e)[0],Object.values(e)[0])))},a.setOutputParamHandler=t=>a.output_handler=t,a.getOutputParamHandler=()=>a.output_handler,a.ctrlChange=(t,e,s)=>{a.fCtrlLabel[e].length&&a.fCtrlLabel[e].forEach((t=>{const e=t.path;a.setParamValue(e,a.remap(s,0,127,t.min,t.max)),a.output_handler&&a.output_handler(e,a.getParamValue(e))}))},a.pitchWheel=(t,e)=>{a.fPitchwheelLabel.forEach((t=>{a.setParamValue(t.path,a.remap(e,0,16383,t.min,t.max)),a.output_handler&&a.output_handler(t.path,a.getParamValue(t.path))}))},a.setParamValue=(t,e)=>a.factory.setParamValue(a.dsp,a.pathTable[t],e),a.getParamValue=t=>a.factory.getParamValue(a.dsp,a.pathTable[t]),a.getParams=()=>a.inputs_items,a.getJSON=()=>this.json,a.initAux(),a}async createDSP(t,e){const s={env:{memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(t,e)=>t%e,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(t,e)=>t-Math.round(t/e)*e,_powf:Math.pow,_roundf:Math.fround,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(t,e)=>t%e,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(t,e)=>t-Math.round(t/e)*e,_pow:Math.pow,_round:Math.fround,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}};try{const n=await fetch(`/Faustlib/${this.name}.wasm`),a=await n.arrayBuffer(),r=await WebAssembly.instantiate(a,s);return this.getNode(r.instance,t,e)}catch(t){this.error(t),this.error("Faust "+this.name+" cannot be loaded or compiled")}}log(t){this._log.push(t),this.debug&&console.log(t)}error(t){this._log.push(t),console.error(t)}}const droneDspName="puretonesScriptProcessor",droneInstance=new FaustWasm2ScriptProcessor(droneDspName);if("undefined"==typeof module)window[droneDspName]=droneInstance;else{const t={};t[droneDspName]=droneInstance,module.exports=t}"undefined"==typeof AudioWorkletNode&&alert("AudioWorklet is not supported in this browser !");class puretonesNode extends AudioWorkletNode{constructor(t,e,s){super(t,"puretones",s),this.baseURL=e,this.json=s.processorOptions.json,this.json_object=JSON.parse(this.json),this.parse_ui=function(t,e){for(var s=0;s<t.length;s++)this.parse_group(t[s],e)},this.parse_group=function(t,e){t.items&&this.parse_items(t.items,e)},this.parse_items=function(t,e){for(var s=0;s<t.length;s++)this.parse_item(t[s],e)},this.parse_item=function(t,e){if("vgroup"===t.type||"hgroup"===t.type||"tgroup"===t.type)this.parse_items(t.items,e);else if("hbargraph"===t.type||"vbargraph"===t.type)e.outputs_items.push(t.address);else if("vslider"===t.type||"hslider"===t.type||"button"===t.type||"checkbox"===t.type||"nentry"===t.type){if(e.inputs_items.push(t.address),e.descriptor.push(t),void 0!==t.meta)for(var s=0;s<t.meta.length;s++)void 0!==t.meta[s].midi&&("pitchwheel"===t.meta[s].midi.trim()?e.fPitchwheelLabel.push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)}):"ctrl"===t.meta[s].midi.trim().split(" ")[0]&&e.fCtrlLabel[parseInt(t.meta[s].midi.trim().split(" ")[1])].push({path:t.address,min:parseFloat(t.min),max:parseFloat(t.max)}));var n="set"+t.address,a="get"+t.address;n=n.replace(/\/./g,(t=>t.substr(1,1).toUpperCase())),a=a.replace(/\/./g,(t=>t.substr(1,1).toUpperCase())),e[n]=s=>{e.setParamValue(t.address,s)},e[a]=()=>e.getParamValue(t.address)}},this.output_handler=null,this.inputs_items=[],this.outputs_items=[],this.descriptor=[],this.fPitchwheelLabel=[],this.fCtrlLabel=new Array(128);for(var n=0;n<this.fCtrlLabel.length;n++)this.fCtrlLabel[n]=[];this.parse_ui(this.json_object.ui,this),this.port.onmessage=this.handleMessage.bind(this);try{this.parameters&&this.parameters.forEach((t=>t.automationRate="k-rate"))}catch(t){}}handleMessage(t){var e=t.data;this.output_handler&&this.output_handler(e.path,e.value)}destroy(){this.port.postMessage({type:"destroy"}),this.port.close()}getJSON(){return this.json}async getMetadata(){return new Promise((t=>{let e=""===this.baseURL?"main.json":this.baseURL+"/main.json";fetch(e).then((t=>t.json())).then((e=>{t(e)}))}))}setParamValue(t,e){this.parameters.get(t).setValueAtTime(e,0)}setParam(t,e){this.parameters.get(t).setValueAtTime(e,0)}getParamValue(t){return this.parameters.get(t).value}getParam(t){return this.parameters.get(t).value}setOutputParamHandler(t){this.output_handler=t}getOutputParamHandler(){return this.output_handler}getNumInputs(){return parseInt(this.json_object.inputs)}getNumOutputs(){return parseInt(this.json_object.outputs)}inputChannelCount(){return parseInt(this.json_object.inputs)}outputChannelCount(){return parseInt(this.json_object.outputs)}getParams(){return this.inputs_items}getDescriptor(){var t={};for(const e in this.descriptor)this.descriptor.hasOwnProperty(e)&&"bypass"!=this.descriptor[e].label&&(t=Object.assign({[this.descriptor[e].label]:{minValue:this.descriptor[e].min,maxValue:this.descriptor[e].max,defaultValue:this.descriptor[e].init}},t));return t}ctrlChange(t,e,s){if(this.fCtrlLabel[e]!==[])for(var n=0;n<this.fCtrlLabel[e].length;n++){var a=this.fCtrlLabel[e][n].path;this.setParamValue(a,puretonesNode.remap(s,0,127,this.fCtrlLabel[e][n].min,this.fCtrlLabel[e][n].max)),this.output_handler&&this.output_handler(a,this.getParamValue(a))}}pitchWheel(t,e){for(var s=0;s<this.fPitchwheelLabel.length;s++){var n=this.fPitchwheelLabel[s];this.setParamValue(n.path,puretonesNode.remap(e,0,16383,n.min,n.max)),this.output_handler&&this.output_handler(n.path,this.getParamValue(n.path))}}midiMessage(t){var e=t[0]>>4,s=15&t[0],n=t[1],a=t[2];9!==s&&(11===e?this.ctrlChange(s,n,a):14===e&&this.pitchWheel(s,128*a+n))}onMidi(t){midiMessage(t)}async getState(){var t=new Object;for(let e=0;e<this.getParams().length;e++)Object.assign(t,{[this.getParams()[e]]:`${this.getParam(this.getParams()[e])}`});return new Promise((e=>{e(t)}))}async setState(t){return new Promise((e=>{for(const e in t)t.hasOwnProperty(e)&&this.setParam(e,t[e]);try{this.gui.setAttribute("state",JSON.stringify(t))}catch(t){console.warn("Plugin without gui or GUI not defined",t)}e(t)}))}setPatch(t){this.setState(this.presets[t])}static remap(t,e,s,n,a){return 1*(t-e)/(s-e)*(a-n)+n}}class puretonesWorklet{static fWorkletProcessors;constructor(t,e=""){this.context=t,this.baseURL=e,this.pathTable=[],this.name="puretonesWorklet",this.fWorkletProcessors=this.fWorkletProcessors||[]}heap2Str(t){let e="",s=0;for(;0!==t[s];)e+=String.fromCharCode(t[s++]);return e}async load(){try{const t={env:{memoryBase:0,tableBase:0,_abs:Math.abs,_acosf:Math.acos,_asinf:Math.asin,_atanf:Math.atan,_atan2f:Math.atan2,_ceilf:Math.ceil,_cosf:Math.cos,_expf:Math.exp,_floorf:Math.floor,_fmodf:(t,e)=>t%e,_logf:Math.log,_log10f:Math.log10,_max_f:Math.max,_min_f:Math.min,_remainderf:(t,e)=>t-Math.round(t/e)*e,_powf:Math.pow,_roundf:Math.fround,_sinf:Math.sin,_sqrtf:Math.sqrt,_tanf:Math.tan,_acoshf:Math.acosh,_asinhf:Math.asinh,_atanhf:Math.atanh,_coshf:Math.cosh,_sinhf:Math.sinh,_tanhf:Math.tanh,_acos:Math.acos,_asin:Math.asin,_atan:Math.atan,_atan2:Math.atan2,_ceil:Math.ceil,_cos:Math.cos,_exp:Math.exp,_floor:Math.floor,_fmod:(t,e)=>t%e,_log:Math.log,_log10:Math.log10,_max_:Math.max,_min_:Math.min,_remainder:(t,e)=>t-Math.round(t/e)*e,_pow:Math.pow,_round:Math.fround,_sin:Math.sin,_sqrt:Math.sqrt,_tan:Math.tan,_acosh:Math.acosh,_asinh:Math.asinh,_atanh:Math.atanh,_cosh:Math.cosh,_sinh:Math.sinh,_tanh:Math.tanh,table:new WebAssembly.Table({initial:0,element:"anyfunc"})}};let e=""===this.baseURL?"puretones.wasm":this.baseURL+"/puretones.wasm";const s=await fetch(e),n=await s.arrayBuffer(),a=await WebAssembly.compile(n),r=await WebAssembly.instantiate(a,t);let i=new Uint8Array(r.exports.memory.buffer),o=this.heap2Str(i),h=JSON.parse(o),p={wasm_module:a,json:o};if(-1===this.fWorkletProcessors.indexOf(this.name))try{let t=/JSON_STR/g,e=puretonesProcessorString.replace(t,o),s=window.URL.createObjectURL(new Blob([e],{type:"text/javascript"}));await this.context.audioWorklet.addModule(s),this.fWorkletProcessors.push(this.name)}catch(t){return console.error(t),console.error("Faust "+this.name+" cannot be loaded or compiled"),null}return this.node=new puretonesNode(this.context,this.baseURL,{numberOfInputs:parseInt(h.inputs)>0?1:0,numberOfOutputs:parseInt(h.outputs)>0?1:0,channelCount:Math.max(1,parseInt(h.inputs)),outputChannelCount:[parseInt(h.outputs)],channelCountMode:"explicit",channelInterpretation:"speakers",processorOptions:p}),this.node.onprocessorerror=()=>{console.log("An error from puretones-processor was detected.")},this.node}catch(t){return console.error(t),console.error("Faust "+this.name+" cannot be loaded or compiled"),null}}}let puretonesProcessorString='\n\n    \'use strict\';\n\n    // Monophonic Faust DSP\n    class puretonesProcessor extends AudioWorkletProcessor {\n        \n        // JSON parsing functions\n        static parse_ui(ui, obj, callback)\n        {\n            for (var i = 0; i < ui.length; i++) {\n                puretonesProcessor.parse_group(ui[i], obj, callback);\n            }\n        }\n        \n        static parse_group(group, obj, callback)\n        {\n            if (group.items) {\n                puretonesProcessor.parse_items(group.items, obj, callback);\n            }\n        }\n        \n        static parse_items(items, obj, callback)\n        {\n            for (var i = 0; i < items.length; i++) {\n                callback(items[i], obj, callback);\n            }\n        }\n        \n        static parse_item1(item, obj, callback)\n        {\n            if (item.type === "vgroup"\n                || item.type === "hgroup"\n                || item.type === "tgroup") {\n                puretonesProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === "hbargraph"\n                       || item.type === "vbargraph") {\n                // Nothing\n            } else if (item.type === "vslider"\n                       || item.type === "hslider"\n                       || item.type === "button"\n                       || item.type === "checkbox"\n                       || item.type === "nentry") {\n                obj.push({ name: item.address,\n                         defaultValue: item.init,\n                         minValue: item.min,\n                         maxValue: item.max });\n            }\n        }\n        \n        static parse_item2(item, obj, callback)\n        {\n            if (item.type === "vgroup"\n                || item.type === "hgroup"\n                || item.type === "tgroup") {\n                puretonesProcessor.parse_items(item.items, obj, callback);\n            } else if (item.type === "hbargraph"\n                       || item.type === "vbargraph") {\n                // Keep bargraph adresses\n                obj.outputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            } else if (item.type === "vslider"\n                       || item.type === "hslider"\n                       || item.type === "button"\n                       || item.type === "checkbox"\n                       || item.type === "nentry") {\n                // Keep inputs adresses\n                obj.inputs_items.push(item.address);\n                obj.pathTable[item.address] = parseInt(item.index);\n            }\n        }\n     \n        static get parameterDescriptors() \n        {\n            // Analyse JSON to generate AudioParam parameters\n            var params = [];\n            puretonesProcessor.parse_ui(JSON.parse(`JSON_STR`).ui, params, puretonesProcessor.parse_item1);\n            return params;\n        }\n       \n        constructor(options)\n        {\n            super(options);\n            this.running = true;\n            this.port.onmessage = this.handleMessage.bind(this);\n            \n            const importObject = {\n                    env: {\n                        memoryBase: 0,\n                        tableBase: 0,\n\n                        // Integer version\n                        _abs: Math.abs,\n\n                        // Float version\n                        _acosf: Math.acos,\n                        _asinf: Math.asin,\n                        _atanf: Math.atan,\n                        _atan2f: Math.atan2,\n                        _ceilf: Math.ceil,\n                        _cosf: Math.cos,\n                        _expf: Math.exp,\n                        _floorf: Math.floor,\n                        _fmodf: function(x, y) { return x % y; },\n                        _logf: Math.log,\n                        _log10f: Math.log10,\n                        _max_f: Math.max,\n                        _min_f: Math.min,\n                        _remainderf: function(x, y) { return x - Math.round(x/y) * y; },\n                        _powf: Math.pow,\n                        _roundf: Math.fround,\n                        _sinf: Math.sin,\n                        _sqrtf: Math.sqrt,\n                        _tanf: Math.tan,\n                        _acoshf: Math.acosh,\n                        _asinhf: Math.asinh,\n                        _atanhf: Math.atanh,\n                        _coshf: Math.cosh,\n                        _sinhf: Math.sinh,\n                        _tanhf: Math.tanh,\n\n                        // Double version\n                        _acos: Math.acos,\n                        _asin: Math.asin,\n                        _atan: Math.atan,\n                        _atan2: Math.atan2,\n                        _ceil: Math.ceil,\n                        _cos: Math.cos,\n                        _exp: Math.exp,\n                        _floor: Math.floor,\n                        _fmod: function(x, y) { return x % y; },\n                        _log: Math.log,\n                        _log10: Math.log10,\n                        _max_: Math.max,\n                        _min_: Math.min,\n                        _remainder:function(x, y) { return x - Math.round(x/y) * y; },\n                        _pow: Math.pow,\n                        _round: Math.fround,\n                        _sin: Math.sin,\n                        _sqrt: Math.sqrt,\n                        _tan: Math.tan,\n                        _acosh: Math.acosh,\n                        _asinh: Math.asinh,\n                        _atanh: Math.atanh,\n                        _cosh: Math.cosh,\n                        _sinh: Math.sinh,\n                        _tanh: Math.tanh,\n\n                        table: new WebAssembly.Table({ initial: 0, element: \'anyfunc\' })\n                    }\n            };\n            \n            this.puretones_instance = new WebAssembly.Instance(options.processorOptions.wasm_module, importObject);\n            this.json_object = JSON.parse(options.processorOptions.json);\n         \n            this.output_handler = function(path, value) { this.port.postMessage({ path: path, value: value }); };\n            \n            this.ins = null;\n            this.outs = null;\n\n            this.dspInChannnels = [];\n            this.dspOutChannnels = [];\n\n            this.numIn = parseInt(this.json_object.inputs);\n            this.numOut = parseInt(this.json_object.outputs);\n\n            // Memory allocator\n            this.ptr_size = 4;\n            this.sample_size = 4;\n            this.integer_size = 4;\n            \n            this.factory = this.puretones_instance.exports;\n            this.HEAP = this.puretones_instance.exports.memory.buffer;\n            this.HEAP32 = new Int32Array(this.HEAP);\n            this.HEAPF32 = new Float32Array(this.HEAP);\n\n            // Warning: keeps a ref on HEAP in Chrome and prevent proper GC\n            //console.log(this.HEAP);\n            //console.log(this.HEAP32);\n            //console.log(this.HEAPF32);\n\n            // bargraph\n            this.outputs_timer = 5;\n            this.outputs_items = [];\n\n            // input items\n            this.inputs_items = [];\n        \n            // Start of HEAP index\n\n            // DSP is placed first with index 0. Audio buffer start at the end of DSP.\n            this.audio_heap_ptr = parseInt(this.json_object.size);\n\n            // Setup pointers offset\n            this.audio_heap_ptr_inputs = this.audio_heap_ptr;\n            this.audio_heap_ptr_outputs = this.audio_heap_ptr_inputs + (this.numIn * this.ptr_size);\n\n            // Setup buffer offset\n            this.audio_heap_inputs = this.audio_heap_ptr_outputs + (this.numOut * this.ptr_size);\n            this.audio_heap_outputs = this.audio_heap_inputs + (this.numIn * NUM_FRAMES * this.sample_size);\n            \n            // Start of DSP memory : DSP is placed first with index 0\n            this.dsp = 0;\n\n            this.pathTable = [];\n         \n            // Send output values to the AudioNode\n            this.update_outputs = function ()\n            {\n                if (this.outputs_items.length > 0 && this.output_handler && this.outputs_timer-- === 0) {\n                    this.outputs_timer = 5;\n                    for (var i = 0; i < this.outputs_items.length; i++) {\n                        this.output_handler(this.outputs_items[i], this.HEAPF32[this.pathTable[this.outputs_items[i]] >> 2]);\n                    }\n                }\n            }\n            \n            this.initAux = function ()\n            {\n                var i;\n                \n                if (this.numIn > 0) {\n                    this.ins = this.audio_heap_ptr_inputs;\n                    for (i = 0; i < this.numIn; i++) {\n                        this.HEAP32[(this.ins >> 2) + i] = this.audio_heap_inputs + ((NUM_FRAMES * this.sample_size) * i);\n                    }\n                    \n                    // Prepare Ins buffer tables\n                    var dspInChans = this.HEAP32.subarray(this.ins >> 2, (this.ins + this.numIn * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numIn; i++) {\n                        this.dspInChannnels[i] = this.HEAPF32.subarray(dspInChans[i] >> 2, (dspInChans[i] + NUM_FRAMES * this.sample_size) >> 2);\n                    }\n                }\n                \n                if (this.numOut > 0) {\n                    this.outs = this.audio_heap_ptr_outputs;\n                    for (i = 0; i < this.numOut; i++) {\n                        this.HEAP32[(this.outs >> 2) + i] = this.audio_heap_outputs + ((NUM_FRAMES * this.sample_size) * i);\n                    }\n                    \n                    // Prepare Out buffer tables\n                    var dspOutChans = this.HEAP32.subarray(this.outs >> 2, (this.outs + this.numOut * this.ptr_size) >> 2);\n                    for (i = 0; i < this.numOut; i++) {\n                        this.dspOutChannnels[i] = this.HEAPF32.subarray(dspOutChans[i] >> 2, (dspOutChans[i] + NUM_FRAMES * this.sample_size) >> 2);\n                    }\n                }\n                \n                // Parse UI\n                puretonesProcessor.parse_ui(this.json_object.ui, this, puretonesProcessor.parse_item2);\n                \n                // Init DSP\n                this.factory.init(this.dsp, sampleRate); // \'sampleRate\' is defined in AudioWorkletGlobalScope  \n            }\n\n            this.setParamValue = function (path, val)\n            {\n                this.HEAPF32[this.pathTable[path] >> 2] = val;\n            }\n\n            this.getParamValue = function (path)\n            {\n                return this.HEAPF32[this.pathTable[path] >> 2];\n            }\n\n            // Init resulting DSP\n            this.initAux();\n        }\n        \n        process(inputs, outputs, parameters) \n        {\n            var input = inputs[0];\n            var output = outputs[0];\n            \n            // Check inputs\n            if (this.numIn > 0 && (!input || !input[0] || input[0].length === 0)) {\n                //console.log("Process input error");\n                return true;\n            }\n            // Check outputs\n            if (this.numOut > 0 && (!output || !output[0] || output[0].length === 0)) {\n                //console.log("Process output error");\n                return true;\n            }\n            \n            // Copy inputs\n            if (input !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numIn, input.length); ++chan) {\n                    var dspInput = this.dspInChannnels[chan];\n                    dspInput.set(input[chan]);\n                }\n            }\n            \n            /*\n            TODO: sample accurate control change is not yet handled\n            When no automation occurs, params[i][1] has a length of 1,\n            otherwise params[i][1] has a length of NUM_FRAMES with possible control change each sample\n            */\n            \n            // Update controls\n            for (const path in parameters) {\n                const paramArray = parameters[path];\n                this.setParamValue(path, paramArray[0]);\n            }\n        \n          \t// Compute\n            try {\n                this.factory.compute(this.dsp, NUM_FRAMES, this.ins, this.outs);\n            } catch(e) {\n                console.log("ERROR in compute (" + e + ")");\n            }\n            \n            // Update bargraph\n            this.update_outputs();\n            \n            // Copy outputs\n            if (output !== undefined) {\n                for (var chan = 0; chan < Math.min(this.numOut, output.length); ++chan) {\n                    var dspOutput = this.dspOutChannnels[chan];\n                    output[chan].set(dspOutput);\n                }\n            }\n            \n            return this.running;\n    \t}\n        \n        handleMessage(event)\n        {\n            var msg = event.data;\n            switch (msg.type) {\n                case "destroy": this.running = false; break;\n            }\n        }\n    }\n\n    // Globals\n    const NUM_FRAMES = 128;\n    try {\n        registerProcessor(\'puretones\', puretonesProcessor);\n    } catch (error) {\n        console.warn(error);\n    }\n';const dspWorkletName="puretones";"undefined"==typeof module?window.puretonesWorklet=puretonesWorklet:module.exports={puretones:puretones};
